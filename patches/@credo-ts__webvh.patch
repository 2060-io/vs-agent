diff --git a/build/anoncreds/services/WebVhAnonCredsRegistry.d.mts b/build/anoncreds/services/WebVhAnonCredsRegistry.d.mts
index 101b63cc2a40175bf0a9bf598406a3f1e9fbc15d..008452821fbc35a886396399c3d89a19edafacd5 100644
--- a/build/anoncreds/services/WebVhAnonCredsRegistry.d.mts
+++ b/build/anoncreds/services/WebVhAnonCredsRegistry.d.mts
@@ -47,21 +47,25 @@ declare class WebVhAnonCredsRegistry implements AnonCredsRegistry {
 type WebVhRegisterSchemaOptions = Omit<RegisterSchemaOptions, 'options'> & {
   options?: {
     verificationMethod?: string;
+    extraMetadata?: Record<string, unknown>;
   };
 };
 type WebVhRegisterCredentialDefinitionOptions = Omit<RegisterCredentialDefinitionOptions, 'options'> & {
   options?: {
     verificationMethod?: string;
+    extraMetadata?: Record<string, unknown>;
   };
 };
 type WebVhRegisterRevocationRegistryDefinitionOptions = Omit<RegisterRevocationRegistryDefinitionOptions, 'options'> & {
   options?: {
     verificationMethod?: string;
+    extraMetadata?: Record<string, unknown>;
   };
 };
 type WebVhRegisterRevocationStatusListOptions = Omit<RegisterRevocationStatusListOptions, 'options'> & {
   options?: {
     verificationMethod?: string;
+    extraMetadata?: Record<string, unknown>;
   };
 };
 //#endregion
diff --git a/build/anoncreds/services/WebVhAnonCredsRegistry.d.mts.map b/build/anoncreds/services/WebVhAnonCredsRegistry.d.mts.map
index bf34f596d1629248025744c2287061f548215d10..d811ab4a1035852efc0119aaa430457c5031701c 100644
--- a/build/anoncreds/services/WebVhAnonCredsRegistry.d.mts.map
+++ b/build/anoncreds/services/WebVhAnonCredsRegistry.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"WebVhAnonCredsRegistry.d.mts","names":[],"sources":["../../../src/anoncreds/services/WebVhAnonCredsRegistry.ts"],"sourcesContent":[],"mappings":";;;;;;;cA6Ca,sBAAA,YAAkC;;;EAAlC,iBAAA,EAAA,OAAuB;EASC;;;EAqHmC,SAAA,mBAAA,EArHnC,MAqHmC;EAmEtD;;;;;;;;;EAgNA,QAAA,gBAAA;EACJ,QAAA,mCAAA;EACD,SAAA,CAAA,YAAA,EArR0B,YAqR1B,EAAA,QAAA,EAAA,MAAA,CAAA,EArR2D,OAqR3D,CArRmE,eAqRnE,CAAA;EAAR,uBAAA,CAAA,YAAA,EAlNa,YAkNb,EAAA,sBAAA,EAAA,MAAA,CAAA,EAhNA,OAgNA,CAhNQ,6BAgNR,CAAA;EA0Ba,+BAAA,CAAA,YAAA,EAhKA,YAgKA,EAAA,8BAAA,EAAA,MAAA,CAAA,EA9Jb,OA8Ja,CA9JL,qCA8JK,CAAA;EACJ,uBAAA,CAAA,YAAA,EApGI,YAoGJ,EAAA,oBAAA,EAAA,MAAA,EAAA,SAAA,EAAA,MAAA,CAAA,EAjGT,OAiGS,CAjGD,6BAiGC,CAAA;EACD,cAAA,CAAA,YAAA,EA9BK,YA8BL,EAAA,OAAA,CAAA,EA7BC,0BA6BD,CAAA,EA5BR,OA4BQ,CA5BA,oBA4BA,CAAA;EAAR,4BAAA,CAAA,YAAA,EAFa,YAEb,EAAA,OAAA,CAAA,EADS,wCACT,CAAA,EAAA,OAAA,CAAQ,kCAAR,CAAA;EA+Ba,oCAAA,CAAA,YAAA,EAAA,YAAA,EAAA,OAAA,CAAA,EACJ,gDADI,CAAA,EAEb,OAFa,CAEL,0CAFK,CAAA;EACJ,kCAAA,CAAA,YAAA,EAiCI,YAjCJ,EAAA,oBAAA,EAAA;IACD,KAAA,CAAA,EAiCuB,KAjCvB;EAAR,CAAA,GAiCyC,MAjCzC,CAAA,MAAA,EAAA,MAAA,CAAA,EAAA,SAAA,EAkCU,MAlCV,CAAA,MAAA,EAAA,MAAA,CAAA,CAAA,EAkCgC,OAlChC,CAAA;IAgCa,oBAAA,EAAA;MACkB,KAAA,EACf,OAAA,GADe,SAAA;IAAU,CAAA;EAC/B,CAAA,CAAA;EAAM,4BAAA,CAAA,YAAA,EAqBH,YArBG,EAAA,OAAA,CAAA,EAsBP,wCAtBO,CAAA,EAuBhB,OAvBgB,CAuBR,kCAvBQ,CAAA;EAAgB,WAAA,CAAA,YAAA,EAwDI,YAxDJ,EAAA,gBAAA,EAwDoC,aAxDpC,CAAA,EAwDoD,OAxDpD,CAAA,OAAA,CAAA;EAqBnB,WAAA,CAAA,YAAA,EAkDA,YAlDA,EAAA,iBAAA,EAmDK,iBAnDL,EAAA,kBAAA,EAAA,MAAA,CAAA,EAoDY,OApDZ,CAmDsB,OAAA,GAnDtB,SAAA,CAAA;EACJ,QAAA,mBAAA;EACD,QAAA,uBAAA;;AAiC4B,KAuG7B,0BAAA,GAA6B,IAvGA,CAuGK,qBAvGL,EAAA,SAAA,CAAA,GAAA;EAAgC,OAAA,CAAA,EAAA;IAAgB,kBAAA,CAAA,EAAA,MAAA;EAevE,CAAA;CACK;AAAiB,KA6F5B,wCAAA,GAA2C,IA7Ff,CA6FoB,mCA7FpB,EAAA,SAAA,CAAA,GAAA;EACV,OAAA,CAAA,EAAA;IA3jBiB,kBAAA,CAAA,EAAA,MAAA;EAAiB,CAAA;AAipBhE,CAAA;AAMY,KAMA,gDAAA,GAAmD,IANH,CAO1D,2CAPyD,EAAA,SAAA,CAAA,GAAA;EAM/C,OAAA,CAAA,EAAA;IASA,kBAAA,CAAA,EAAA,MAAA;;;KAAA,wCAAA,GAA2C,KAAK"}
\ No newline at end of file
+{"version":3,"file":"WebVhAnonCredsRegistry.d.mts","names":[],"sources":["../../../src/anoncreds/services/WebVhAnonCredsRegistry.ts"],"mappings":";;;;;;;cA6Ca,sBAAA,YAAkC,iBAAA;EACtC,UAAA;EAEA,aAAA;EACA,iBAAA;EAJ2B;;;EAAA,SASlB,mBAAA,EAAmB,MAAA;EAqH2C;;;;;;;;;EAAA,QA1GtE,gBAAA;EAAA,QAMM,mCAAA;EAoGD,SAAA,CAAU,YAAA,EAAc,YAAA,EAAc,QAAA,WAAmB,OAAA,CAAQ,eAAA;EAkEjE,uBAAA,CACX,YAAA,EAAc,YAAA,EACd,sBAAA,WACC,OAAA,CAAQ,6BAAA;EAyEE,+BAAA,CACX,YAAA,EAAc,YAAA,EACd,8BAAA,WACC,OAAA,CAAQ,qCAAA;EA0DE,uBAAA,CACX,YAAA,EAAc,YAAA,EACd,oBAAA,UACA,SAAA,WACC,OAAA,CAAQ,6BAAA;EAmEE,cAAA,CACX,YAAA,EAAc,YAAA,EACd,OAAA,GAAU,0BAAA,GACT,OAAA,CAAQ,oBAAA;EA0BE,4BAAA,CACX,YAAA,EAAc,YAAA,EACd,OAAA,GAAU,wCAAA,GACT,OAAA,CAAQ,kCAAA;EA+BE,oCAAA,CACX,YAAA,EAAc,YAAA,EACd,OAAA,GAAU,gDAAA,GACT,OAAA,CAAQ,0CAAA;EAgCE,kCAAA,CACX,YAAA,EAAc,YAAA,EACd,oBAAA;IAAwB,KAAA,GAAQ,KAAA;EAAA,IAAU,MAAA,kBAC1C,SAAA,EAAW,MAAA,mBAAsB,OAAA;;aAAhB,OAAA;IAAA;EAAA;EAoBN,4BAAA,CACX,YAAA,EAAc,YAAA,EACd,OAAA,GAAU,wCAAA,GACT,OAAA,CAAQ,kCAAA;EAkCE,WAAA,CAAY,YAAA,EAAc,YAAA,EAAc,gBAAA,EAAkB,aAAA,GAAgB,OAAA;EAc1E,WAAA,CACX,YAAA,EAAc,YAAA,EACd,iBAAA,EAAmB,iBAAA,EACnB,kBAAA,WAA0B,OAAA,CADU,OAAA;EAAA,QAoBxB,mBAAA;EAAA,QAyCA,uBAAA;AAAA;AAAA,KA0BJ,0BAAA,GAA6B,IAAA,CAAK,qBAAA;EAC5C,OAAA;IACE,kBAAA;IACA,aAAA,GAAgB,MAAA;EAAA;AAAA;AAAA,KAIR,wCAAA,GAA2C,IAAA,CAAK,mCAAA;EAC1D,OAAA;IACE,kBAAA;IACA,aAAA,GAAgB,MAAA;EAAA;AAAA;AAAA,KAIR,gDAAA,GAAmD,IAAA,CAC7D,2CAAA;EAGA,OAAA;IACE,kBAAA;IACA,aAAA,GAAgB,MAAA;EAAA;AAAA;AAAA,KAIR,wCAAA,GAA2C,IAAA,CAAK,mCAAA;EAC1D,OAAA;IACE,kBAAA;IACA,aAAA,GAAgB,MAAA;EAAA;AAAA"}
\ No newline at end of file
diff --git a/build/anoncreds/services/WebVhAnonCredsRegistry.mjs b/build/anoncreds/services/WebVhAnonCredsRegistry.mjs
index e3a62a2e5d3b3f40b615916566fd7f3f90dffc3b..9e1bc0e0e94365dc86fc18042baa28fb952c7c38 100644
--- a/build/anoncreds/services/WebVhAnonCredsRegistry.mjs
+++ b/build/anoncreds/services/WebVhAnonCredsRegistry.mjs
@@ -230,7 +230,8 @@ var WebVhAnonCredsRegistry = class {
 			metadata: {
 				resourceId,
 				resourceType: "anonCredsSchema",
-				resourceName: options.schema.name
+				resourceName: options.schema.name,
+				...options.options?.extraMetadata
 			},
 			issuerId: options.schema.issuerId,
 			verificationMethod: options?.options?.verificationMethod
@@ -255,7 +256,8 @@ var WebVhAnonCredsRegistry = class {
 			metadata: {
 				resourceId,
 				resourceType: "anonCredsCredDef",
-				resourceName: options.credentialDefinition.tag
+				resourceName: options.credentialDefinition.tag,
+				...options.options?.extraMetadata
 			},
 			issuerId: options.credentialDefinition.issuerId,
 			verificationMethod: options.options?.verificationMethod
@@ -280,7 +282,8 @@ var WebVhAnonCredsRegistry = class {
 			metadata: {
 				resourceId,
 				resourceType: "anonCredsRevocRegDef",
-				resourceName: options.revocationRegistryDefinition.tag
+				resourceName: options.revocationRegistryDefinition.tag,
+				...options.options?.extraMetadata
 			},
 			issuerId: options.revocationRegistryDefinition.issuerId,
 			verificationMethod: options.options?.verificationMethod
@@ -321,7 +324,8 @@ var WebVhAnonCredsRegistry = class {
 			metadata: {
 				resourceId,
 				resourceType: "anonCredsStatusList",
-				resourceName: "0"
+				resourceName: "0",
+				...options.options?.extraMetadata
 			},
 			issuerId: options.revocationStatusList.issuerId,
 			verificationMethod: options?.options?.verificationMethod
diff --git a/build/anoncreds/services/WebVhAnonCredsRegistry.mjs.map b/build/anoncreds/services/WebVhAnonCredsRegistry.mjs.map
index 6b451a1ceccc9fac4b99ce1dd0e6726bda687a1c..a5c85fb005a8eda3ae89a04bd27b2c487833b30f 100644
--- a/build/anoncreds/services/WebVhAnonCredsRegistry.mjs.map
+++ b/build/anoncreds/services/WebVhAnonCredsRegistry.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"WebVhAnonCredsRegistry.mjs","names":["resourceObject: WebVhResource","revocationEntryId: string | undefined"],"sources":["../../../src/anoncreds/services/WebVhAnonCredsRegistry.ts"],"sourcesContent":["import type {\n  AnonCredsCredentialDefinition,\n  AnonCredsRegistry,\n  AnonCredsRevocationRegistryDefinition,\n  AnonCredsRevocationRegistryDefinitionValue,\n  AnonCredsRevocationStatusList,\n  AnonCredsRevocationStatusListWithoutTimestamp,\n  AnonCredsSchema,\n  GetCredentialDefinitionReturn,\n  GetRevocationRegistryDefinitionReturn,\n  GetRevocationStatusListReturn,\n  GetSchemaReturn,\n  RegisterCredentialDefinitionOptions,\n  RegisterCredentialDefinitionReturn,\n  RegisterRevocationRegistryDefinitionOptions,\n  RegisterRevocationRegistryDefinitionReturn,\n  RegisterRevocationStatusListOptions,\n  RegisterRevocationStatusListReturn,\n  RegisterSchemaOptions,\n  RegisterSchemaReturn,\n} from '@credo-ts/anoncreds'\n\nimport {\n  type AgentContext,\n  CredoError,\n  DidRepository,\n  JsonTransformer,\n  MultiBaseEncoder,\n  MultiHashEncoder,\n  type Proof,\n  TypedArrayEncoder,\n} from '@credo-ts/core'\nimport { canonicalize } from 'json-canonicalize'\nimport { EddsaJcs2022Cryptosuite, type UnsecuredDocument } from '../../cryptosuites'\nimport { WebVhDidResolver } from '../../dids'\nimport { WebVhResource } from '../utils/transform'\n\ntype DidResourceResolutionResult = {\n  error?: string\n  message?: string\n  content?: Record<string, unknown> | unknown[] | string // More specific than any, but still flexible\n  contentMetadata?: Record<string, unknown>\n  dereferencingMetadata?: Record<string, unknown>\n}\n\nexport class WebVhAnonCredsRegistry implements AnonCredsRegistry {\n  public methodName = 'webvh'\n\n  public allowsCaching = true\n  public allowsLocalRecord = true\n\n  /**\n   * This class supports resolving objects with did:webvh identifiers.\n   */\n  public readonly supportedIdentifier = /^did:webvh:.*/\n\n  /**\n   * Resolves a resource using the WebVhDidResolver and performs common validation steps.\n   *\n   * @param agentContext The agent context.\n   * @param resourceId The DID URI of the resource to resolve.\n   * @param resourceTypeString A descriptive string for the resource type (e.g., 'schema', 'credential definition') used in logs/errors.\n   * @returns The parsed and validated WebVhResource object and the original resolution result.\n   * @throws {CredoError} If resolution, parsing, or validation fails.\n   */\n  private _digestMultibase(value: string) {\n    const valueBytes = TypedArrayEncoder.fromString(value)\n    const digestMultihash = MultiHashEncoder.encode(valueBytes, 'sha-256')\n    const digestMultibase = MultiBaseEncoder.encode(digestMultihash, 'base58btc')\n    return digestMultibase\n  }\n  private async _resolveAndValidateAttestedResource(\n    agentContext: AgentContext,\n    resourceId: string,\n    resourceTypeString: string\n  ): Promise<{ resourceObject: WebVhResource; resolutionResult: DidResourceResolutionResult }> {\n    try {\n      const webvhDidResolver = agentContext.dependencyManager.resolve(WebVhDidResolver)\n      if (!this.supportedIdentifier.test(resourceId))\n        throw new CredoError(`Invalid ${resourceTypeString} ID: ${resourceId}`)\n\n      agentContext.config.logger.trace(\n        `Attempting to resolve ${resourceTypeString} resource '${resourceId}' via did:webvh resolver`\n      )\n\n      const resolutionResult = await webvhDidResolver.resolveResource(agentContext, resourceId)\n\n      if (!resolutionResult) {\n        throw new CredoError(`Resource resolution returned null/undefined for ${resourceId}`)\n      }\n\n      if ('error' in resolutionResult || !('content' in resolutionResult)) {\n        throw new CredoError(\n          `Resource ${resourceId} could not be resolved or is missing data. Error: ${resolutionResult.error || 'unknown'} - ${resolutionResult.message || 'no message'}`\n        )\n      }\n\n      let resourceObject: WebVhResource\n      try {\n        agentContext.config.logger.trace(\n          `Parsing resource data: ${JSON.stringify(resolutionResult.content).substring(0, 200)}...`\n        )\n        resourceObject = JsonTransformer.fromJSON(resolutionResult.content, WebVhResource)\n      } catch (parseError) {\n        agentContext.config.logger.error(`Failed to parse resource data for ${resourceId}`, {\n          error: parseError instanceof Error ? parseError.message : String(parseError),\n          stack: parseError instanceof Error ? parseError.stack : undefined,\n        })\n        throw new CredoError(\n          `Failed to parse resource data for ${resourceId}: ${\n            parseError instanceof Error ? parseError.message : String(parseError)\n          }`\n        )\n      }\n\n      // --- Attested Resource Validation steps ---\n\n      // 1. Data Model Verification\n      if (!Array.isArray(resourceObject.type) || !resourceObject.type.includes('AttestedResource')) {\n        throw new CredoError('Missing AttestedResource type.')\n      }\n      if (!resourceObject.id || typeof resourceObject.id !== 'string') {\n        throw new CredoError('Missing resource id.')\n      }\n      if (!resourceObject.content || typeof resourceObject.content !== 'object') {\n        throw new CredoError('Missing resource content.')\n      }\n      if (resourceObject.metadata && typeof resourceObject.metadata !== 'object') {\n        throw new CredoError('Expecting metadata to be an object.')\n      }\n      if (resourceObject.links && typeof resourceObject.links !== 'object') {\n        throw new CredoError('Expecting metadata to be an array.')\n      }\n      if (!resourceObject.proof || typeof resourceObject.proof !== 'object') {\n        throw new CredoError('Missing resource proof.')\n      }\n      agentContext.config.logger.trace(`Resource ${resourceId} attestation found.`)\n\n      // 2. DataIntegrityProof Verification\n      const verified = await this.verifyProof(agentContext, resourceObject)\n      if (!verified) {\n        agentContext.config.logger.trace('Resolved resource proof is invalid.')\n        throw new CredoError('Resolved resource proof is invalid.')\n      }\n      agentContext.config.logger.trace(`Resource ${resourceId} proof validated.`)\n\n      // 3. Resource Digest Multibase Verification\n      if (resourceObject.id !== resourceId) {\n        throw new CredoError(`ID mismatch ${resourceObject.id} != ${resourceId}`)\n      }\n      const parts = resourceId.split(/[:/]/)\n      const expectedMultibaseHash = parts[parts.length - 1]\n      if (!expectedMultibaseHash) {\n        throw new CredoError(`Could not extract expected hash from ${resourceTypeString} ID: ${resourceId}`)\n      }\n      const digestMultibase = this._digestMultibase(canonicalize(resourceObject.content))\n\n      if (digestMultibase !== expectedMultibaseHash) {\n        throw new CredoError(\n          `Content hash mismatch for ${resourceId}. Expected: ${expectedMultibaseHash}, Actual: ${digestMultibase}`\n        )\n      }\n      agentContext.config.logger.trace(`Resource ${resourceId} content hash matches filename.`)\n\n      return { resourceObject, resolutionResult }\n    } catch (error) {\n      agentContext.config.logger.error('Error in did:webvh _resolveAndValidateAttestedResource:', error)\n      throw error\n    }\n  }\n\n  public async getSchema(agentContext: AgentContext, schemaId: string): Promise<GetSchemaReturn> {\n    try {\n      const { resourceObject, resolutionResult } = await this._resolveAndValidateAttestedResource(\n        agentContext,\n        schemaId,\n        'schema'\n      )\n\n      // --- Parsing Step (Simplified) ---\n      const schemaContent = resourceObject.content\n\n      // Type check to ensure we have a schema content object\n      if (\n        !('attrNames' in schemaContent) ||\n        !('name' in schemaContent) ||\n        !('version' in schemaContent) ||\n        !('issuerId' in schemaContent)\n      ) {\n        throw new CredoError(`Parsed resource content for ${schemaId} is not a valid schema.`)\n      }\n\n      const contentIssuerId = (schemaContent as { issuerId?: string })?.issuerId // Type assertion for accessing issuerId\n      if (!contentIssuerId || typeof contentIssuerId !== 'string') {\n        throw new CredoError(`Resolved resource content for ${schemaId} is missing a valid issuerId.`)\n      }\n\n      const resourceDidMatch = schemaId.match(/^(did:webvh:[^/]+)/)\n      if (!resourceDidMatch || !resourceDidMatch[1]) {\n        throw new CredoError(`Could not extract DID from resource ID: ${schemaId}`)\n      }\n      const expectedIssuerDid = resourceDidMatch[1]\n\n      if (contentIssuerId !== expectedIssuerDid) {\n        throw new CredoError(\n          `Issuer ID mismatch for ${schemaId}. Expected: ${expectedIssuerDid}, Actual: ${contentIssuerId}`\n        )\n      }\n\n      return {\n        schema: {\n          attrNames: schemaContent.attrNames,\n          name: schemaContent.name,\n          version: schemaContent.version,\n          issuerId: contentIssuerId,\n        },\n        schemaId,\n        resolutionMetadata: resolutionResult.dereferencingMetadata || {},\n        schemaMetadata: resourceObject.metadata || {},\n      }\n    } catch (error) {\n      agentContext.config.logger.error(`Error retrieving schema '${schemaId}' via did:webvh`, {\n        error: error instanceof Error ? error.message : String(error),\n        schemaId,\n      })\n\n      return {\n        schemaId,\n        resolutionMetadata: {\n          error: 'invalid',\n          message: `unable to resolve schema: ${error instanceof Error ? error.message : String(error)}`,\n        },\n        schemaMetadata: {},\n      }\n    }\n  }\n\n  public async getCredentialDefinition(\n    agentContext: AgentContext,\n    credentialDefinitionId: string\n  ): Promise<GetCredentialDefinitionReturn> {\n    try {\n      const { resourceObject, resolutionResult } = await this._resolveAndValidateAttestedResource(\n        agentContext,\n        credentialDefinitionId,\n        'credential definition'\n      )\n\n      // Extract the content and make sure it's a CredDef\n      const credDefContent = resourceObject.content\n      // Type check for WebVhCredDefContent\n      if (\n        !('schemaId' in credDefContent) ||\n        !('type' in credDefContent) ||\n        !('tag' in credDefContent) ||\n        !('value' in credDefContent)\n      ) {\n        throw new CredoError('Resolved resource content is not a valid credential definition.')\n      }\n\n      const contentIssuerId = (credDefContent as { issuerId?: string })?.issuerId\n      if (!contentIssuerId || typeof contentIssuerId !== 'string') {\n        throw new CredoError(`Resolved resource content for ${credentialDefinitionId} is missing a valid issuerId.`)\n      }\n\n      // Extract the DID from the resourceId (part before /resources/hash)\n      const resourceDidMatch = credentialDefinitionId.match(/^(did:webvh:[^/]+)/)\n      if (!resourceDidMatch || !resourceDidMatch[1]) {\n        throw new CredoError(`Could not extract DID from resource ID: ${credentialDefinitionId}`)\n      }\n      const expectedIssuerDid = resourceDidMatch[1]\n\n      if (contentIssuerId !== expectedIssuerDid) {\n        throw new CredoError(\n          `Issuer ID mismatch for ${credentialDefinitionId}. Expected: ${expectedIssuerDid}, Actual: ${contentIssuerId}`\n        )\n      }\n\n      // Extract metadata from the resolved resource\n      const credDefMetadata = resourceObject.metadata || resolutionResult.contentMetadata || {}\n\n      return {\n        credentialDefinition: {\n          issuerId: credDefContent.issuerId,\n          schemaId: credDefContent.schemaId,\n          type: 'CL' as const, // Assuming CL type for now, might need adjustment if other types are supported\n          tag: credDefContent.tag,\n          value: credDefContent.value as { primary: Record<string, unknown>; revocation?: unknown }, // Assuming structure\n        },\n        credentialDefinitionId,\n        resolutionMetadata: resolutionResult.dereferencingMetadata || {},\n        credentialDefinitionMetadata: credDefMetadata,\n      }\n    } catch (error) {\n      agentContext.config.logger.error(\n        `Error retrieving credential definition '${credentialDefinitionId}' via did:webvh`,\n        {\n          error: error instanceof Error ? error.message : String(error),\n          credentialDefinitionId,\n        }\n      )\n\n      return {\n        credentialDefinitionId,\n        resolutionMetadata: {\n          error: 'invalid',\n          message: `unable to resolve credential definition: ${error instanceof Error ? error.message : String(error)}`,\n        },\n        credentialDefinitionMetadata: {},\n      }\n    }\n  }\n\n  public async getRevocationRegistryDefinition(\n    agentContext: AgentContext,\n    revocationRegistryDefinitionId: string\n  ): Promise<GetRevocationRegistryDefinitionReturn> {\n    try {\n      const { resourceObject, resolutionResult } = await this._resolveAndValidateAttestedResource(\n        agentContext,\n        revocationRegistryDefinitionId,\n        'revocation registry definition'\n      )\n\n      const revRegDefContent = resourceObject.content\n\n      if (\n        !('revocDefType' in revRegDefContent) ||\n        !('credDefId' in revRegDefContent) ||\n        !('tag' in revRegDefContent) ||\n        !('value' in revRegDefContent)\n      ) {\n        throw new CredoError(\n          `Parsed resource content for ${revocationRegistryDefinitionId} is not a valid revocation registry definition.`\n        )\n      }\n\n      // Extract metadata\n      const revRegDefMetadata = resourceObject.metadata || resolutionResult.contentMetadata || {}\n\n      return {\n        revocationRegistryDefinition: {\n          issuerId: revRegDefContent.issuerId,\n          revocDefType: revRegDefContent.revocDefType as AnonCredsRevocationRegistryDefinition['revocDefType'], // TODO: Map revocDefType string to AnonCreds type\n          credDefId: revRegDefContent.credDefId,\n          tag: revRegDefContent.tag,\n          value: revRegDefContent.value as AnonCredsRevocationRegistryDefinitionValue, // TODO: Map value structure to AnonCreds type\n        },\n        revocationRegistryDefinitionId,\n        resolutionMetadata: resolutionResult.dereferencingMetadata || {},\n        revocationRegistryDefinitionMetadata: revRegDefMetadata,\n      }\n    } catch (error) {\n      agentContext.config.logger.error(\n        `Error retrieving revocation registry definition '${revocationRegistryDefinitionId}' via did:webvh`,\n        {\n          error: error instanceof Error ? error.message : String(error),\n          revocationRegistryDefinitionId,\n        }\n      )\n\n      return {\n        revocationRegistryDefinitionId,\n        resolutionMetadata: {\n          error: 'invalid',\n          message: `unable to resolve revocation registry definition: ${\n            error instanceof Error ? error.message : String(error)\n          }`,\n        },\n        revocationRegistryDefinitionMetadata: {},\n      }\n    }\n  }\n\n  public async getRevocationStatusList(\n    agentContext: AgentContext,\n    revocationRegistryId: string,\n    timestamp: number\n  ): Promise<GetRevocationStatusListReturn> {\n    try {\n      if (!revocationRegistryId.startsWith('did:webvh:'))\n        throw new CredoError(`Invalid revocationRegistryId: ${revocationRegistryId}`)\n\n      agentContext.config.logger.trace(\n        `Attempting to resolve revocation status list resource for '${revocationRegistryId}' at timestamp ${timestamp} via did:webvh resolver`\n      )\n      const { resourceObject } = await this._resolveAndValidateAttestedResource(\n        agentContext,\n        revocationRegistryId,\n        'revocation status list'\n      )\n      if (!resourceObject.links) {\n        throw new CredoError('No revocation entries found.')\n      }\n\n      const revocationEntries = resourceObject.links\n        .filter((entry) => entry.timestamp != null)\n        .sort((a, b) => (a.timestamp ?? 0) - (b.timestamp ?? 0))\n      if (!revocationEntries || revocationEntries.length === 0) {\n        throw new CredoError('No revocation entries found.')\n      }\n\n      let revocationEntryId: string | undefined\n      for (const [index, entry] of revocationEntries?.entries() ?? []) {\n        if (entry.timestamp && entry.timestamp > timestamp) {\n          revocationEntryId = revocationEntries?.[index - 1]?.id\n          break\n        }\n      }\n      if (!revocationEntryId) {\n        revocationEntryId = revocationEntries?.[revocationEntries.length - 1]?.id\n      }\n\n      const { resourceObject: revocationEntryResourceObject, resolutionResult: revocationEntryResolutionResult } =\n        await this._resolveAndValidateAttestedResource(agentContext, revocationEntryId, 'revocation status list entry')\n\n      if (!revocationEntryResourceObject) {\n        throw new CredoError('No revocation entry found for the given timestamp.')\n      }\n\n      return {\n        revocationStatusList: revocationEntryResourceObject.content as AnonCredsRevocationStatusList,\n        resolutionMetadata: revocationEntryResolutionResult.dereferencingMetadata || {},\n        revocationStatusListMetadata: revocationEntryResourceObject.metadata || {},\n      }\n    } catch (error) {\n      agentContext.config.logger.error(\n        `Error retrieving revocation registry status list '${revocationRegistryId}' via did:webvh`,\n        {\n          error: error instanceof Error ? error.message : String(error),\n          revocationRegistryId,\n          timestamp,\n        }\n      )\n\n      return {\n        resolutionMetadata: {\n          error: 'notFound',\n          message: `unable to resolve revocation registry status list: ${error.message}`,\n        },\n        revocationStatusListMetadata: {},\n      }\n    }\n  }\n\n  public async registerSchema(\n    agentContext: AgentContext,\n    options?: WebVhRegisterSchemaOptions\n  ): Promise<RegisterSchemaReturn> {\n    if (!options?.schema) throw new CredoError('Schema options must be provided.')\n\n    const resourceId = this._digestMultibase(canonicalize(options.schema))\n    const schemaId = `${options.schema.issuerId}/resources/${resourceId}`\n\n    const attestedResource = await this.buildSignedResource(agentContext, {\n      content: options.schema,\n      id: schemaId,\n      metadata: {\n        resourceId,\n        resourceType: 'anonCredsSchema',\n        resourceName: options.schema.name,\n      },\n      issuerId: options.schema.issuerId,\n      verificationMethod: options?.options?.verificationMethod,\n    })\n\n    return {\n      schemaState: { state: 'finished', schema: options.schema, schemaId },\n      registrationMetadata: { attestedResource },\n      schemaMetadata: {},\n    }\n  }\n\n  public async registerCredentialDefinition(\n    agentContext: AgentContext,\n    options?: WebVhRegisterCredentialDefinitionOptions\n  ): Promise<RegisterCredentialDefinitionReturn> {\n    if (!options?.credentialDefinition) throw new CredoError('credentialDefinition options must be provided.')\n\n    const resourceId = this._digestMultibase(canonicalize(options.credentialDefinition))\n\n    const credentialDefinitionId = `${options.credentialDefinition.issuerId}/resources/${resourceId}`\n\n    const attestedResource = await this.buildSignedResource(agentContext, {\n      content: options.credentialDefinition,\n      id: credentialDefinitionId,\n      metadata: {\n        resourceId,\n        resourceType: 'anonCredsCredDef',\n        resourceName: options.credentialDefinition.tag,\n      },\n      issuerId: options.credentialDefinition.issuerId,\n      verificationMethod: options.options?.verificationMethod,\n    })\n\n    return {\n      credentialDefinitionState: {\n        state: 'finished',\n        credentialDefinition: options.credentialDefinition,\n        credentialDefinitionId,\n      },\n      credentialDefinitionMetadata: {},\n      registrationMetadata: { attestedResource },\n    }\n  }\n\n  public async registerRevocationRegistryDefinition(\n    agentContext: AgentContext,\n    options?: WebVhRegisterRevocationRegistryDefinitionOptions\n  ): Promise<RegisterRevocationRegistryDefinitionReturn> {\n    if (!options?.revocationRegistryDefinition)\n      throw new CredoError('revocationRegistryDefinition options must be provided.')\n\n    const resourceId = this._digestMultibase(canonicalize(options.revocationRegistryDefinition))\n\n    const revocationRegistryDefinitionId = `${options.revocationRegistryDefinition.issuerId}/resources/${resourceId}`\n\n    const attestedResource = await this.buildSignedResource(agentContext, {\n      content: options.revocationRegistryDefinition,\n      id: revocationRegistryDefinitionId,\n      metadata: {\n        resourceId,\n        resourceType: 'anonCredsRevocRegDef',\n        resourceName: options.revocationRegistryDefinition.tag,\n      },\n      issuerId: options.revocationRegistryDefinition.issuerId,\n      verificationMethod: options.options?.verificationMethod,\n    })\n\n    return {\n      revocationRegistryDefinitionState: {\n        state: 'finished',\n        revocationRegistryDefinition: options.revocationRegistryDefinition,\n        revocationRegistryDefinitionId,\n      },\n      registrationMetadata: { attestedResource },\n      revocationRegistryDefinitionMetadata: {},\n    }\n  }\n\n  public async updateRevocationRegistryDefinition(\n    agentContext: AgentContext,\n    registrationMetadata: { proof?: Proof } & Record<string, object>,\n    extraInfo: Record<string, object>\n  ) {\n    const { proof, ...restMetadata } = registrationMetadata\n\n    const vm = proof?.verificationMethod\n    if (!vm) throw new Error('verificationMethod not found in proof')\n    const verificationMethod = typeof vm === 'string' ? vm : vm.id\n\n    const updatedMetadata = { ...restMetadata, ...extraInfo }\n\n    const newProof = await this.createProof(agentContext, updatedMetadata, verificationMethod)\n\n    return {\n      registrationMetadata: {\n        ...updatedMetadata,\n        proof: newProof,\n      },\n    }\n  }\n\n  public async registerRevocationStatusList(\n    agentContext: AgentContext,\n    options?: WebVhRegisterRevocationStatusListOptions\n  ): Promise<RegisterRevocationStatusListReturn> {\n    if (!options?.revocationStatusList) throw new CredoError('revocationStatusList options must be provided.')\n\n    const timestamp = Math.floor(Date.now() / 1000)\n    const resourceId = this._digestMultibase(canonicalize(options.revocationStatusList))\n\n    const resourceStatusListId = `${options.revocationStatusList.issuerId}/resources/${resourceId}`\n\n    const attestedResource = await this.buildSignedResource(agentContext, {\n      content: options.revocationStatusList,\n      id: resourceStatusListId,\n      metadata: {\n        resourceId,\n        resourceType: 'anonCredsStatusList',\n        resourceName: '0',\n      },\n      issuerId: options.revocationStatusList.issuerId,\n      verificationMethod: options?.options?.verificationMethod,\n    })\n\n    return {\n      revocationStatusListState: {\n        state: 'finished',\n        revocationStatusList: { ...options.revocationStatusList, timestamp },\n      },\n      registrationMetadata: { attestedResource },\n      revocationStatusListMetadata: {\n        previousVersionId: '',\n        nextVersionId: '',\n      },\n    }\n  }\n\n  public async verifyProof(agentContext: AgentContext, attestedResource: WebVhResource): Promise<boolean> {\n    const cryptosuite = new EddsaJcs2022Cryptosuite(agentContext)\n    try {\n      const verificationResult = await cryptosuite.verifyProof(attestedResource)\n      return verificationResult.verified\n    } catch (error) {\n      agentContext.config.logger.error('Error during proof validation of did:webvh resource', {\n        error: error instanceof Error ? error.message : String(error),\n        stack: error instanceof Error ? error.stack : undefined,\n      })\n      return false\n    }\n  }\n\n  public async createProof(\n    agentContext: AgentContext,\n    unsecuredDocument: UnsecuredDocument,\n    verificationMethod: string\n  ) {\n    const cryptosuite = new EddsaJcs2022Cryptosuite(agentContext)\n    try {\n      const creationResult = await cryptosuite.createProof(unsecuredDocument, {\n        type: 'DataIntegrityProof',\n        cryptosuite: 'eddsa-jcs-2022',\n        verificationMethod,\n        proofPurpose: 'assertionMethod',\n      })\n      return creationResult\n    } catch (error) {\n      agentContext.config.logger.error('Error during proof creation of did:webvh resource', {\n        error: error instanceof Error ? error.message : String(error),\n        stack: error instanceof Error ? error.stack : undefined,\n      })\n    }\n  }\n\n  private async buildSignedResource(\n    agentContext: AgentContext,\n    {\n      content,\n      id,\n      metadata,\n      issuerId,\n      verificationMethod,\n    }: {\n      content:\n        | AnonCredsSchema\n        | AnonCredsCredentialDefinition\n        | AnonCredsRevocationRegistryDefinition\n        | AnonCredsRevocationStatusListWithoutTimestamp\n      id: string\n      metadata: Record<string, unknown>\n      issuerId: string\n      verificationMethod?: string\n    }\n  ) {\n    const verificationMethodId = await this.getVerificationMethodId(agentContext, issuerId, verificationMethod)\n\n    // Prepare the generic resource payload to be signed\n    const resourcePayload = {\n      '@context': [\n        'https://identity.foundation/did-attested-resources/context/v0.1',\n        'https://w3id.org/security/data-integrity/v2',\n      ],\n      type: ['AttestedResource'],\n      id,\n      content,\n      metadata,\n    }\n\n    const proof = await this.createProof(agentContext, resourcePayload, verificationMethodId)\n    return {\n      ...resourcePayload,\n      proof,\n    }\n  }\n\n  private async getVerificationMethodId(\n    agentContext: AgentContext,\n    issuerId: string,\n    explicitVerificationMethod?: string\n  ): Promise<string> {\n    const didRepository = agentContext.dependencyManager.resolve(DidRepository)\n\n    const didRecord = await didRepository.findCreatedDid(agentContext, issuerId)\n    if (!didRecord) {\n      throw new CredoError(`No DID found for issuer ${issuerId}`)\n    }\n\n    // Use the explicit verification method if provided, otherwise use the first available with publicKeyMultibase\n    const verificationMethod =\n      explicitVerificationMethod ??\n      (didRecord.didDocument?.verificationMethod?.[0]?.publicKeyMultibase\n        ? didRecord.didDocument.verificationMethod[0].id\n        : undefined)\n\n    if (!verificationMethod) {\n      throw new CredoError(`No verification method found for DID ${didRecord.id}`)\n    }\n    return verificationMethod\n  }\n}\n\nexport type WebVhRegisterSchemaOptions = Omit<RegisterSchemaOptions, 'options'> & {\n  options?: {\n    verificationMethod?: string\n  }\n}\n\nexport type WebVhRegisterCredentialDefinitionOptions = Omit<RegisterCredentialDefinitionOptions, 'options'> & {\n  options?: {\n    verificationMethod?: string\n  }\n}\n\nexport type WebVhRegisterRevocationRegistryDefinitionOptions = Omit<\n  RegisterRevocationRegistryDefinitionOptions,\n  'options'\n> & {\n  options?: {\n    verificationMethod?: string\n  }\n}\n\nexport type WebVhRegisterRevocationStatusListOptions = Omit<RegisterRevocationStatusListOptions, 'options'> & {\n  options?: {\n    verificationMethod?: string\n  }\n}\n"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"WebVhAnonCredsRegistry.mjs","names":[],"sources":["../../../src/anoncreds/services/WebVhAnonCredsRegistry.ts"],"sourcesContent":["import type {\n  AnonCredsCredentialDefinition,\n  AnonCredsRegistry,\n  AnonCredsRevocationRegistryDefinition,\n  AnonCredsRevocationRegistryDefinitionValue,\n  AnonCredsRevocationStatusList,\n  AnonCredsRevocationStatusListWithoutTimestamp,\n  AnonCredsSchema,\n  GetCredentialDefinitionReturn,\n  GetRevocationRegistryDefinitionReturn,\n  GetRevocationStatusListReturn,\n  GetSchemaReturn,\n  RegisterCredentialDefinitionOptions,\n  RegisterCredentialDefinitionReturn,\n  RegisterRevocationRegistryDefinitionOptions,\n  RegisterRevocationRegistryDefinitionReturn,\n  RegisterRevocationStatusListOptions,\n  RegisterRevocationStatusListReturn,\n  RegisterSchemaOptions,\n  RegisterSchemaReturn,\n} from '@credo-ts/anoncreds'\n\nimport {\n  type AgentContext,\n  CredoError,\n  DidRepository,\n  JsonTransformer,\n  MultiBaseEncoder,\n  MultiHashEncoder,\n  type Proof,\n  TypedArrayEncoder,\n} from '@credo-ts/core'\nimport { canonicalize } from 'json-canonicalize'\nimport { EddsaJcs2022Cryptosuite, type UnsecuredDocument } from '../../cryptosuites'\nimport { WebVhDidResolver } from '../../dids'\nimport { WebVhResource } from '../utils/transform'\n\ntype DidResourceResolutionResult = {\n  error?: string\n  message?: string\n  content?: Record<string, unknown> | unknown[] | string // More specific than any, but still flexible\n  contentMetadata?: Record<string, unknown>\n  dereferencingMetadata?: Record<string, unknown>\n}\n\nexport class WebVhAnonCredsRegistry implements AnonCredsRegistry {\n  public methodName = 'webvh'\n\n  public allowsCaching = true\n  public allowsLocalRecord = true\n\n  /**\n   * This class supports resolving objects with did:webvh identifiers.\n   */\n  public readonly supportedIdentifier = /^did:webvh:.*/\n\n  /**\n   * Resolves a resource using the WebVhDidResolver and performs common validation steps.\n   *\n   * @param agentContext The agent context.\n   * @param resourceId The DID URI of the resource to resolve.\n   * @param resourceTypeString A descriptive string for the resource type (e.g., 'schema', 'credential definition') used in logs/errors.\n   * @returns The parsed and validated WebVhResource object and the original resolution result.\n   * @throws {CredoError} If resolution, parsing, or validation fails.\n   */\n  private _digestMultibase(value: string) {\n    const valueBytes = TypedArrayEncoder.fromString(value)\n    const digestMultihash = MultiHashEncoder.encode(valueBytes, 'sha-256')\n    const digestMultibase = MultiBaseEncoder.encode(digestMultihash, 'base58btc')\n    return digestMultibase\n  }\n  private async _resolveAndValidateAttestedResource(\n    agentContext: AgentContext,\n    resourceId: string,\n    resourceTypeString: string\n  ): Promise<{ resourceObject: WebVhResource; resolutionResult: DidResourceResolutionResult }> {\n    try {\n      const webvhDidResolver = agentContext.dependencyManager.resolve(WebVhDidResolver)\n      if (!this.supportedIdentifier.test(resourceId))\n        throw new CredoError(`Invalid ${resourceTypeString} ID: ${resourceId}`)\n\n      agentContext.config.logger.trace(\n        `Attempting to resolve ${resourceTypeString} resource '${resourceId}' via did:webvh resolver`\n      )\n\n      const resolutionResult = await webvhDidResolver.resolveResource(agentContext, resourceId)\n\n      if (!resolutionResult) {\n        throw new CredoError(`Resource resolution returned null/undefined for ${resourceId}`)\n      }\n\n      if ('error' in resolutionResult || !('content' in resolutionResult)) {\n        throw new CredoError(\n          `Resource ${resourceId} could not be resolved or is missing data. Error: ${resolutionResult.error || 'unknown'} - ${resolutionResult.message || 'no message'}`\n        )\n      }\n\n      let resourceObject: WebVhResource\n      try {\n        agentContext.config.logger.trace(\n          `Parsing resource data: ${JSON.stringify(resolutionResult.content).substring(0, 200)}...`\n        )\n        resourceObject = JsonTransformer.fromJSON(resolutionResult.content, WebVhResource)\n      } catch (parseError) {\n        agentContext.config.logger.error(`Failed to parse resource data for ${resourceId}`, {\n          error: parseError instanceof Error ? parseError.message : String(parseError),\n          stack: parseError instanceof Error ? parseError.stack : undefined,\n        })\n        throw new CredoError(\n          `Failed to parse resource data for ${resourceId}: ${\n            parseError instanceof Error ? parseError.message : String(parseError)\n          }`\n        )\n      }\n\n      // --- Attested Resource Validation steps ---\n\n      // 1. Data Model Verification\n      if (!Array.isArray(resourceObject.type) || !resourceObject.type.includes('AttestedResource')) {\n        throw new CredoError('Missing AttestedResource type.')\n      }\n      if (!resourceObject.id || typeof resourceObject.id !== 'string') {\n        throw new CredoError('Missing resource id.')\n      }\n      if (!resourceObject.content || typeof resourceObject.content !== 'object') {\n        throw new CredoError('Missing resource content.')\n      }\n      if (resourceObject.metadata && typeof resourceObject.metadata !== 'object') {\n        throw new CredoError('Expecting metadata to be an object.')\n      }\n      if (resourceObject.links && typeof resourceObject.links !== 'object') {\n        throw new CredoError('Expecting metadata to be an array.')\n      }\n      if (!resourceObject.proof || typeof resourceObject.proof !== 'object') {\n        throw new CredoError('Missing resource proof.')\n      }\n      agentContext.config.logger.trace(`Resource ${resourceId} attestation found.`)\n\n      // 2. DataIntegrityProof Verification\n      const verified = await this.verifyProof(agentContext, resourceObject)\n      if (!verified) {\n        agentContext.config.logger.trace('Resolved resource proof is invalid.')\n        throw new CredoError('Resolved resource proof is invalid.')\n      }\n      agentContext.config.logger.trace(`Resource ${resourceId} proof validated.`)\n\n      // 3. Resource Digest Multibase Verification\n      if (resourceObject.id !== resourceId) {\n        throw new CredoError(`ID mismatch ${resourceObject.id} != ${resourceId}`)\n      }\n      const parts = resourceId.split(/[:/]/)\n      const expectedMultibaseHash = parts[parts.length - 1]\n      if (!expectedMultibaseHash) {\n        throw new CredoError(`Could not extract expected hash from ${resourceTypeString} ID: ${resourceId}`)\n      }\n      const digestMultibase = this._digestMultibase(canonicalize(resourceObject.content))\n\n      if (digestMultibase !== expectedMultibaseHash) {\n        throw new CredoError(\n          `Content hash mismatch for ${resourceId}. Expected: ${expectedMultibaseHash}, Actual: ${digestMultibase}`\n        )\n      }\n      agentContext.config.logger.trace(`Resource ${resourceId} content hash matches filename.`)\n\n      return { resourceObject, resolutionResult }\n    } catch (error) {\n      agentContext.config.logger.error('Error in did:webvh _resolveAndValidateAttestedResource:', error)\n      throw error\n    }\n  }\n\n  public async getSchema(agentContext: AgentContext, schemaId: string): Promise<GetSchemaReturn> {\n    try {\n      const { resourceObject, resolutionResult } = await this._resolveAndValidateAttestedResource(\n        agentContext,\n        schemaId,\n        'schema'\n      )\n\n      // --- Parsing Step (Simplified) ---\n      const schemaContent = resourceObject.content\n\n      // Type check to ensure we have a schema content object\n      if (\n        !('attrNames' in schemaContent) ||\n        !('name' in schemaContent) ||\n        !('version' in schemaContent) ||\n        !('issuerId' in schemaContent)\n      ) {\n        throw new CredoError(`Parsed resource content for ${schemaId} is not a valid schema.`)\n      }\n\n      const contentIssuerId = (schemaContent as { issuerId?: string })?.issuerId // Type assertion for accessing issuerId\n      if (!contentIssuerId || typeof contentIssuerId !== 'string') {\n        throw new CredoError(`Resolved resource content for ${schemaId} is missing a valid issuerId.`)\n      }\n\n      const resourceDidMatch = schemaId.match(/^(did:webvh:[^/]+)/)\n      if (!resourceDidMatch || !resourceDidMatch[1]) {\n        throw new CredoError(`Could not extract DID from resource ID: ${schemaId}`)\n      }\n      const expectedIssuerDid = resourceDidMatch[1]\n\n      if (contentIssuerId !== expectedIssuerDid) {\n        throw new CredoError(\n          `Issuer ID mismatch for ${schemaId}. Expected: ${expectedIssuerDid}, Actual: ${contentIssuerId}`\n        )\n      }\n\n      return {\n        schema: {\n          attrNames: schemaContent.attrNames,\n          name: schemaContent.name,\n          version: schemaContent.version,\n          issuerId: contentIssuerId,\n        },\n        schemaId,\n        resolutionMetadata: resolutionResult.dereferencingMetadata || {},\n        schemaMetadata: resourceObject.metadata || {},\n      }\n    } catch (error) {\n      agentContext.config.logger.error(`Error retrieving schema '${schemaId}' via did:webvh`, {\n        error: error instanceof Error ? error.message : String(error),\n        schemaId,\n      })\n\n      return {\n        schemaId,\n        resolutionMetadata: {\n          error: 'invalid',\n          message: `unable to resolve schema: ${error instanceof Error ? error.message : String(error)}`,\n        },\n        schemaMetadata: {},\n      }\n    }\n  }\n\n  public async getCredentialDefinition(\n    agentContext: AgentContext,\n    credentialDefinitionId: string\n  ): Promise<GetCredentialDefinitionReturn> {\n    try {\n      const { resourceObject, resolutionResult } = await this._resolveAndValidateAttestedResource(\n        agentContext,\n        credentialDefinitionId,\n        'credential definition'\n      )\n\n      // Extract the content and make sure it's a CredDef\n      const credDefContent = resourceObject.content\n      // Type check for WebVhCredDefContent\n      if (\n        !('schemaId' in credDefContent) ||\n        !('type' in credDefContent) ||\n        !('tag' in credDefContent) ||\n        !('value' in credDefContent)\n      ) {\n        throw new CredoError('Resolved resource content is not a valid credential definition.')\n      }\n\n      const contentIssuerId = (credDefContent as { issuerId?: string })?.issuerId\n      if (!contentIssuerId || typeof contentIssuerId !== 'string') {\n        throw new CredoError(`Resolved resource content for ${credentialDefinitionId} is missing a valid issuerId.`)\n      }\n\n      // Extract the DID from the resourceId (part before /resources/hash)\n      const resourceDidMatch = credentialDefinitionId.match(/^(did:webvh:[^/]+)/)\n      if (!resourceDidMatch || !resourceDidMatch[1]) {\n        throw new CredoError(`Could not extract DID from resource ID: ${credentialDefinitionId}`)\n      }\n      const expectedIssuerDid = resourceDidMatch[1]\n\n      if (contentIssuerId !== expectedIssuerDid) {\n        throw new CredoError(\n          `Issuer ID mismatch for ${credentialDefinitionId}. Expected: ${expectedIssuerDid}, Actual: ${contentIssuerId}`\n        )\n      }\n\n      // Extract metadata from the resolved resource\n      const credDefMetadata = resourceObject.metadata || resolutionResult.contentMetadata || {}\n\n      return {\n        credentialDefinition: {\n          issuerId: credDefContent.issuerId,\n          schemaId: credDefContent.schemaId,\n          type: 'CL' as const, // Assuming CL type for now, might need adjustment if other types are supported\n          tag: credDefContent.tag,\n          value: credDefContent.value as { primary: Record<string, unknown>; revocation?: unknown }, // Assuming structure\n        },\n        credentialDefinitionId,\n        resolutionMetadata: resolutionResult.dereferencingMetadata || {},\n        credentialDefinitionMetadata: credDefMetadata,\n      }\n    } catch (error) {\n      agentContext.config.logger.error(\n        `Error retrieving credential definition '${credentialDefinitionId}' via did:webvh`,\n        {\n          error: error instanceof Error ? error.message : String(error),\n          credentialDefinitionId,\n        }\n      )\n\n      return {\n        credentialDefinitionId,\n        resolutionMetadata: {\n          error: 'invalid',\n          message: `unable to resolve credential definition: ${error instanceof Error ? error.message : String(error)}`,\n        },\n        credentialDefinitionMetadata: {},\n      }\n    }\n  }\n\n  public async getRevocationRegistryDefinition(\n    agentContext: AgentContext,\n    revocationRegistryDefinitionId: string\n  ): Promise<GetRevocationRegistryDefinitionReturn> {\n    try {\n      const { resourceObject, resolutionResult } = await this._resolveAndValidateAttestedResource(\n        agentContext,\n        revocationRegistryDefinitionId,\n        'revocation registry definition'\n      )\n\n      const revRegDefContent = resourceObject.content\n\n      if (\n        !('revocDefType' in revRegDefContent) ||\n        !('credDefId' in revRegDefContent) ||\n        !('tag' in revRegDefContent) ||\n        !('value' in revRegDefContent)\n      ) {\n        throw new CredoError(\n          `Parsed resource content for ${revocationRegistryDefinitionId} is not a valid revocation registry definition.`\n        )\n      }\n\n      // Extract metadata\n      const revRegDefMetadata = resourceObject.metadata || resolutionResult.contentMetadata || {}\n\n      return {\n        revocationRegistryDefinition: {\n          issuerId: revRegDefContent.issuerId,\n          revocDefType: revRegDefContent.revocDefType as AnonCredsRevocationRegistryDefinition['revocDefType'], // TODO: Map revocDefType string to AnonCreds type\n          credDefId: revRegDefContent.credDefId,\n          tag: revRegDefContent.tag,\n          value: revRegDefContent.value as AnonCredsRevocationRegistryDefinitionValue, // TODO: Map value structure to AnonCreds type\n        },\n        revocationRegistryDefinitionId,\n        resolutionMetadata: resolutionResult.dereferencingMetadata || {},\n        revocationRegistryDefinitionMetadata: revRegDefMetadata,\n      }\n    } catch (error) {\n      agentContext.config.logger.error(\n        `Error retrieving revocation registry definition '${revocationRegistryDefinitionId}' via did:webvh`,\n        {\n          error: error instanceof Error ? error.message : String(error),\n          revocationRegistryDefinitionId,\n        }\n      )\n\n      return {\n        revocationRegistryDefinitionId,\n        resolutionMetadata: {\n          error: 'invalid',\n          message: `unable to resolve revocation registry definition: ${\n            error instanceof Error ? error.message : String(error)\n          }`,\n        },\n        revocationRegistryDefinitionMetadata: {},\n      }\n    }\n  }\n\n  public async getRevocationStatusList(\n    agentContext: AgentContext,\n    revocationRegistryId: string,\n    timestamp: number\n  ): Promise<GetRevocationStatusListReturn> {\n    try {\n      if (!revocationRegistryId.startsWith('did:webvh:'))\n        throw new CredoError(`Invalid revocationRegistryId: ${revocationRegistryId}`)\n\n      agentContext.config.logger.trace(\n        `Attempting to resolve revocation status list resource for '${revocationRegistryId}' at timestamp ${timestamp} via did:webvh resolver`\n      )\n      const { resourceObject } = await this._resolveAndValidateAttestedResource(\n        agentContext,\n        revocationRegistryId,\n        'revocation status list'\n      )\n      if (!resourceObject.links) {\n        throw new CredoError('No revocation entries found.')\n      }\n\n      const revocationEntries = resourceObject.links\n        .filter((entry) => entry.timestamp != null)\n        .sort((a, b) => (a.timestamp ?? 0) - (b.timestamp ?? 0))\n      if (!revocationEntries || revocationEntries.length === 0) {\n        throw new CredoError('No revocation entries found.')\n      }\n\n      let revocationEntryId: string | undefined\n      for (const [index, entry] of revocationEntries?.entries() ?? []) {\n        if (entry.timestamp && entry.timestamp > timestamp) {\n          revocationEntryId = revocationEntries?.[index - 1]?.id\n          break\n        }\n      }\n      if (!revocationEntryId) {\n        revocationEntryId = revocationEntries?.[revocationEntries.length - 1]?.id\n      }\n\n      const { resourceObject: revocationEntryResourceObject, resolutionResult: revocationEntryResolutionResult } =\n        await this._resolveAndValidateAttestedResource(agentContext, revocationEntryId, 'revocation status list entry')\n\n      if (!revocationEntryResourceObject) {\n        throw new CredoError('No revocation entry found for the given timestamp.')\n      }\n\n      return {\n        revocationStatusList: revocationEntryResourceObject.content as AnonCredsRevocationStatusList,\n        resolutionMetadata: revocationEntryResolutionResult.dereferencingMetadata || {},\n        revocationStatusListMetadata: revocationEntryResourceObject.metadata || {},\n      }\n    } catch (error) {\n      agentContext.config.logger.error(\n        `Error retrieving revocation registry status list '${revocationRegistryId}' via did:webvh`,\n        {\n          error: error instanceof Error ? error.message : String(error),\n          revocationRegistryId,\n          timestamp,\n        }\n      )\n\n      return {\n        resolutionMetadata: {\n          error: 'notFound',\n          message: `unable to resolve revocation registry status list: ${error.message}`,\n        },\n        revocationStatusListMetadata: {},\n      }\n    }\n  }\n\n  public async registerSchema(\n    agentContext: AgentContext,\n    options?: WebVhRegisterSchemaOptions\n  ): Promise<RegisterSchemaReturn> {\n    if (!options?.schema) throw new CredoError('Schema options must be provided.')\n\n    const resourceId = this._digestMultibase(canonicalize(options.schema))\n    const schemaId = `${options.schema.issuerId}/resources/${resourceId}`\n\n    const attestedResource = await this.buildSignedResource(agentContext, {\n      content: options.schema,\n      id: schemaId,\n      metadata: {\n        resourceId,\n        resourceType: 'anonCredsSchema',\n        resourceName: options.schema.name,\n        ...options.options?.extraMetadata,\n      },\n      issuerId: options.schema.issuerId,\n      verificationMethod: options?.options?.verificationMethod,\n    })\n\n    return {\n      schemaState: { state: 'finished', schema: options.schema, schemaId },\n      registrationMetadata: { attestedResource },\n      schemaMetadata: {},\n    }\n  }\n\n  public async registerCredentialDefinition(\n    agentContext: AgentContext,\n    options?: WebVhRegisterCredentialDefinitionOptions\n  ): Promise<RegisterCredentialDefinitionReturn> {\n    if (!options?.credentialDefinition) throw new CredoError('credentialDefinition options must be provided.')\n\n    const resourceId = this._digestMultibase(canonicalize(options.credentialDefinition))\n\n    const credentialDefinitionId = `${options.credentialDefinition.issuerId}/resources/${resourceId}`\n\n    const attestedResource = await this.buildSignedResource(agentContext, {\n      content: options.credentialDefinition,\n      id: credentialDefinitionId,\n      metadata: {\n        resourceId,\n        resourceType: 'anonCredsCredDef',\n        resourceName: options.credentialDefinition.tag,\n        ...options.options?.extraMetadata,        \n      },\n      issuerId: options.credentialDefinition.issuerId,\n      verificationMethod: options.options?.verificationMethod,\n    })\n\n    return {\n      credentialDefinitionState: {\n        state: 'finished',\n        credentialDefinition: options.credentialDefinition,\n        credentialDefinitionId,\n      },\n      credentialDefinitionMetadata: {},\n      registrationMetadata: { attestedResource },\n    }\n  }\n\n  public async registerRevocationRegistryDefinition(\n    agentContext: AgentContext,\n    options?: WebVhRegisterRevocationRegistryDefinitionOptions\n  ): Promise<RegisterRevocationRegistryDefinitionReturn> {\n    if (!options?.revocationRegistryDefinition)\n      throw new CredoError('revocationRegistryDefinition options must be provided.')\n\n    const resourceId = this._digestMultibase(canonicalize(options.revocationRegistryDefinition))\n\n    const revocationRegistryDefinitionId = `${options.revocationRegistryDefinition.issuerId}/resources/${resourceId}`\n\n    const attestedResource = await this.buildSignedResource(agentContext, {\n      content: options.revocationRegistryDefinition,\n      id: revocationRegistryDefinitionId,\n      metadata: {\n        resourceId,\n        resourceType: 'anonCredsRevocRegDef',\n        resourceName: options.revocationRegistryDefinition.tag,\n        ...options.options?.extraMetadata,\n      },\n      issuerId: options.revocationRegistryDefinition.issuerId,\n      verificationMethod: options.options?.verificationMethod,\n    })\n\n    return {\n      revocationRegistryDefinitionState: {\n        state: 'finished',\n        revocationRegistryDefinition: options.revocationRegistryDefinition,\n        revocationRegistryDefinitionId,\n      },\n      registrationMetadata: { attestedResource },\n      revocationRegistryDefinitionMetadata: {},\n    }\n  }\n\n  public async updateRevocationRegistryDefinition(\n    agentContext: AgentContext,\n    registrationMetadata: { proof?: Proof } & Record<string, object>,\n    extraInfo: Record<string, object>\n  ) {\n    const { proof, ...restMetadata } = registrationMetadata\n\n    const vm = proof?.verificationMethod\n    if (!vm) throw new Error('verificationMethod not found in proof')\n    const verificationMethod = typeof vm === 'string' ? vm : vm.id\n\n    const updatedMetadata = { ...restMetadata, ...extraInfo }\n\n    const newProof = await this.createProof(agentContext, updatedMetadata, verificationMethod)\n\n    return {\n      registrationMetadata: {\n        ...updatedMetadata,\n        proof: newProof,\n      },\n    }\n  }\n\n  public async registerRevocationStatusList(\n    agentContext: AgentContext,\n    options?: WebVhRegisterRevocationStatusListOptions\n  ): Promise<RegisterRevocationStatusListReturn> {\n    if (!options?.revocationStatusList) throw new CredoError('revocationStatusList options must be provided.')\n\n    const timestamp = Math.floor(Date.now() / 1000)\n    const resourceId = this._digestMultibase(canonicalize(options.revocationStatusList))\n\n    const resourceStatusListId = `${options.revocationStatusList.issuerId}/resources/${resourceId}`\n\n    const attestedResource = await this.buildSignedResource(agentContext, {\n      content: options.revocationStatusList,\n      id: resourceStatusListId,\n      metadata: {\n        resourceId,\n        resourceType: 'anonCredsStatusList',\n        resourceName: '0',\n        ...options.options?.extraMetadata,\n      },\n      issuerId: options.revocationStatusList.issuerId,\n      verificationMethod: options?.options?.verificationMethod,\n    })\n\n    return {\n      revocationStatusListState: {\n        state: 'finished',\n        revocationStatusList: { ...options.revocationStatusList, timestamp },\n      },\n      registrationMetadata: { attestedResource },\n      revocationStatusListMetadata: {\n        previousVersionId: '',\n        nextVersionId: '',\n      },\n    }\n  }\n\n  public async verifyProof(agentContext: AgentContext, attestedResource: WebVhResource): Promise<boolean> {\n    const cryptosuite = new EddsaJcs2022Cryptosuite(agentContext)\n    try {\n      const verificationResult = await cryptosuite.verifyProof(attestedResource)\n      return verificationResult.verified\n    } catch (error) {\n      agentContext.config.logger.error('Error during proof validation of did:webvh resource', {\n        error: error instanceof Error ? error.message : String(error),\n        stack: error instanceof Error ? error.stack : undefined,\n      })\n      return false\n    }\n  }\n\n  public async createProof(\n    agentContext: AgentContext,\n    unsecuredDocument: UnsecuredDocument,\n    verificationMethod: string\n  ) {\n    const cryptosuite = new EddsaJcs2022Cryptosuite(agentContext)\n    try {\n      const creationResult = await cryptosuite.createProof(unsecuredDocument, {\n        type: 'DataIntegrityProof',\n        cryptosuite: 'eddsa-jcs-2022',\n        verificationMethod,\n        proofPurpose: 'assertionMethod',\n      })\n      return creationResult\n    } catch (error) {\n      agentContext.config.logger.error('Error during proof creation of did:webvh resource', {\n        error: error instanceof Error ? error.message : String(error),\n        stack: error instanceof Error ? error.stack : undefined,\n      })\n    }\n  }\n\n  private async buildSignedResource(\n    agentContext: AgentContext,\n    {\n      content,\n      id,\n      metadata,\n      issuerId,\n      verificationMethod,\n    }: {\n      content:\n        | AnonCredsSchema\n        | AnonCredsCredentialDefinition\n        | AnonCredsRevocationRegistryDefinition\n        | AnonCredsRevocationStatusListWithoutTimestamp\n      id: string\n      metadata: Record<string, unknown>\n      issuerId: string\n      verificationMethod?: string\n    }\n  ) {\n    const verificationMethodId = await this.getVerificationMethodId(agentContext, issuerId, verificationMethod)\n\n    // Prepare the generic resource payload to be signed\n    const resourcePayload = {\n      '@context': [\n        'https://identity.foundation/did-attested-resources/context/v0.1',\n        'https://w3id.org/security/data-integrity/v2',\n      ],\n      type: ['AttestedResource'],\n      id,\n      content,\n      metadata,\n    }\n\n    const proof = await this.createProof(agentContext, resourcePayload, verificationMethodId)\n    return {\n      ...resourcePayload,\n      proof,\n    }\n  }\n\n  private async getVerificationMethodId(\n    agentContext: AgentContext,\n    issuerId: string,\n    explicitVerificationMethod?: string\n  ): Promise<string> {\n    const didRepository = agentContext.dependencyManager.resolve(DidRepository)\n\n    const didRecord = await didRepository.findCreatedDid(agentContext, issuerId)\n    if (!didRecord) {\n      throw new CredoError(`No DID found for issuer ${issuerId}`)\n    }\n\n    // Use the explicit verification method if provided, otherwise use the first available with publicKeyMultibase\n    const verificationMethod =\n      explicitVerificationMethod ??\n      (didRecord.didDocument?.verificationMethod?.[0]?.publicKeyMultibase\n        ? didRecord.didDocument.verificationMethod[0].id\n        : undefined)\n\n    if (!verificationMethod) {\n      throw new CredoError(`No verification method found for DID ${didRecord.id}`)\n    }\n    return verificationMethod\n  }\n}\n\nexport type WebVhRegisterSchemaOptions = Omit<RegisterSchemaOptions, 'options'> & {\n  options?: {\n    verificationMethod?: string\n    extraMetadata?: Record<string, unknown>\n  }\n}\n\nexport type WebVhRegisterCredentialDefinitionOptions = Omit<RegisterCredentialDefinitionOptions, 'options'> & {\n  options?: {\n    verificationMethod?: string\n    extraMetadata?: Record<string, unknown>    \n  }\n}\n\nexport type WebVhRegisterRevocationRegistryDefinitionOptions = Omit<\n  RegisterRevocationRegistryDefinitionOptions,\n  'options'\n> & {\n  options?: {\n    verificationMethod?: string\n    extraMetadata?: Record<string, unknown>    \n  }\n}\n\nexport type WebVhRegisterRevocationStatusListOptions = Omit<RegisterRevocationStatusListOptions, 'options'> & {\n  options?: {\n    verificationMethod?: string\n    extraMetadata?: Record<string, unknown>    \n  }\n}\n"],"mappings":"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"}
